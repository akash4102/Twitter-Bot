from flask import Flask
import tweepy
import requests
from datetime import datetime, timedelta
import pytz

app = Flask(__name__)


def get_new_tweet_text_for_reply(tweet_text):
    response = requests.post('http://localhost:13000/generate/tweet', json={'prompt': tweet_text})
    return response.json()


def get_new_tweet_text_for_trend(top_tweets,hashtag):
    prompt= f"these are the tweets for hashtag {hashtag} and top tweets are {top_tweets} create a tweet for this this hashtag {hashtag} after reading all the tweets carefully and use same hashtag name in it please don't mention anything that shows these tweets generated by AI just like according to you, as a AI etc"
    response = requests.post('http://localhost:13000/generate/tweet', json={'prompt': prompt})
    return response.json()

def get_trending_hashtags(api, woeid):
    trends = api.get_place_trends(id=woeid)
    trending_hashtags = [trend['name'] for trend in trends[0]['trends'] if trend['name'].startswith('#')]
    return trending_hashtags[:20]

def get_top_tweets(api, hashtag):
    tweets = tweepy.Cursor(api.search_tweets, q=hashtag, tweet_mode='extended', result_type='popular').items(50)
    return [tweet.full_text for tweet in tweets]

def get_most_retweeted_tweet(api, username):
    tweets = api.user_timeline(screen_name=username, count=200)
    one_day_ago = datetime.now(pytz.UTC) - timedelta(days=1)
    last_day_tweets = [tweet for tweet in tweets if tweet.created_at > one_day_ago]

    if last_day_tweets:
        most_retweeted_tweet = max(last_day_tweets, key=lambda tweet: tweet.retweet_count)
        return most_retweeted_tweet
    else:
        return None



@app.route('/api/reply', methods=['GET'])
def reply_tweet():
    usernames = ['@elonmusk','@BillGates','@Ashneer_Grover','@sama','@narendramodi','@BarackObama','@justinbieber','@Cristiano','@NASA','@isro','@imVkohli','@ChuckRobbins','@ajassy','@kunalb11','@bhash','@vijayshekhar','@riteshagar','@deepigoyal','@amangupta0303','@RNTata2000']  # hardcoded list of usernames
    
    success_responses = []
    failure_responses = []
    
    for username in usernames:
        try:
            tweet = get_most_retweeted_tweet(api, username)
            if tweet is not None:
                prompt = f"{tweet.text} this tweet is tweeted by this {username} twitter handle after carefully review the tweet please generate a reply tweet that is relevant to this tweet and if you don't find something that relevant to this tweet just provide some positive and nice tweet for reply and you can also ask some relevant question to that tweet"
                new_tweet_text = get_new_tweet_text_for_reply(prompt)
                print(f"New tweet for {username}: {new_tweet_text}")
                api.update_status(
                    status=new_tweet_text['tweet'], 
                    in_reply_to_status_id=tweet.id, 
                    auto_populate_reply_metadata=True
                )
                success_responses.append(f"Reply tweet posted for {username}")
            else:
                failure_responses.append(f"No tweet found for {username}")
        except Exception as e:
            failure_responses.append(f"Failed to process user {username}: {str(e)}")

    return {"success": success_responses, "failure": failure_responses}, 200

def open_file(filepath):
    with open(filepath, 'r', encoding='utf-8') as infile:
        return infile.read().strip()

@app.route('/api/trends', methods=['GET'])
def tweet_for_trend():
    woeid = 23424848  # hardcoded woeid
    try:
        trending_hashtags = get_trending_hashtags(api, woeid)
        for hashtag in trending_hashtags:
            print(f"Fetching tweets for {hashtag}...")
            top_tweets = get_top_tweets(api, hashtag)
            new_tweet = get_new_tweet_text_for_trend(top_tweets, hashtag)
            print(new_tweet)
            api.update_status(status=new_tweet['tweet'])
        return {"message": f"Posted tweets for trending hashtags"}, 200
    except Exception as e:
        return {"error": str(e)}, 500


if __name__ == '__main__':
    auth = tweepy.OAuthHandler(open_file('key_tweepy1.txt'), open_file('key_tweepy2.txt'))
    auth.set_access_token(open_file('key_tweepy3.txt'), open_file('key_tweepy4.txt'))
    api = tweepy.API(auth)
    app.run(debug=True, host='0.0.0.0', port=13001)
